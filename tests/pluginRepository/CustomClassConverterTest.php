<?php

require_once dirname(__FILE__) . '/../../pluginRepository/CustomClassConverter.php';
require_once dirname(__FILE__) . '/../../amfphp/AMFPHPClassLoader.php';
require_once dirname(__FILE__) . "/../testData/customClasses/TestCustomClass1.php";
require_once dirname(__FILE__) . "/../testData/customClasses/TestCustomClass2.php";

/**
 * Test class for CustomClassConverter.
 * Generated by PHPUnit on 2011-01-20 at 11:18:02.
 */
class CustomClassConverterTest extends PHPUnit_Framework_TestCase {

    /**
     * @var CustomClassConverter
     */
    protected $object;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp() {
        $this->object = new CustomClassConverter;
        $this->object->customClassFolderPaths[] = dirname(__FILE__) . "/../testData/customClasses";
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown() {

    }

    public function testPacketRequestDeserializedHandler() {
        
        $explicitTypeField = Amfphp_Core_Amf_Constants::FIELD_EXPLICIT_TYPE;
        //3 level object: TestCustomClass1, untyped, TestCustomClass2 with some data around
        $testObj1 = new stdClass();
        $testObj1->$explicitTypeField = "TestCustomClass1";
        $testObj1->data = "bla1";
        $subObj1 = new stdClass();
        $subObj1->data = "bla2";
        $subObj2 = new stdClass();
        $subObj2->$explicitTypeField = "TestCustomClass2";
        $subObj2->data = "bla3";
        $subObj1->sub = $subObj2;
        $testObj1->sub = $subObj1;

        $testMessage = new Amfphp_Core_Amf_Message(null, null, array($testObj1));
        $testPacket = new Amfphp_Core_Amf_Packet();
        $testPacket->messages[] = $testMessage;
        $ret = $this->object->packetRequestDeserializedHandler($testPacket);
        $modifiedPacket = $ret[0];
        $modifiedObj = $modifiedPacket->messages[0]->data[0];
        $this->assertEquals("TestCustomClass1", get_class($modifiedObj));
        $this->assertEquals("bla1", $modifiedObj->data);
        $this->assertEquals("stdClass", get_class($modifiedObj->sub));
        $this->assertEquals("bla2", $modifiedObj->sub->data);
        $this->assertEquals("TestCustomClass2", get_class($modifiedObj->sub->sub));
        $this->assertEquals("bla3", $modifiedObj->sub->sub->data);

        //test using a class that isn't loaded yet
        $testObj2 = new stdClass();
        $testObj2->$explicitTypeField = "TestCustomClass3";
        $testMessage = new Amfphp_Core_Amf_Message(null, null, array($testObj2));
        $testPacket = new Amfphp_Core_Amf_Packet();
        $testPacket->messages[] = $testMessage;
        $ret = $this->object->packetRequestDeserializedHandler($testPacket);
        $modifiedPacket = $ret[0];
        $modifiedObj = $modifiedPacket->messages[0]->data[0];
        $this->assertEquals("TestCustomClass3", get_class($modifiedObj));

        //test using a class that isn't available. The data should be left untouched for now
        $testObj3 = new stdClass();
        $testObj3->$explicitTypeField = "flex.messaging.Bla";
        $testMessage = new Amfphp_Core_Amf_Message(null, null, array($testObj3));
        $testPacket = new Amfphp_Core_Amf_Packet();
        $testPacket->messages[] = $testMessage;
        $ret = $this->object->packetRequestDeserializedHandler($testPacket);
        $modifiedPacket = $ret[0];
        $modifiedObj = $modifiedPacket->messages[0]->data[0];
        $this->assertEquals("flex.messaging.Bla", $modifiedObj->$explicitTypeField);


    }

    public function testPacketResponseDeserializedHandler() {
        $explicitTypeField = Amfphp_Core_Amf_Constants::FIELD_EXPLICIT_TYPE;
        //3 level object: TestCustomClass1, untyped, TestCustomClass2 with some data around
        $testObj1 = new TestCustomClass1();
        $testObj1->data = "bla1";
        $subObj1 = new stdClass();
        $subObj1->data = "bla2";
        $subObj2 = new TestCustomClass2();
        $subObj2->data = "bla3";
        $subObj1->sub = $subObj2;
        $testObj1->sub = $subObj1;

        $testMessage = new Amfphp_Core_Amf_Message(null,null, $testObj1);
        $testPacket = new Amfphp_Core_Amf_Packet();
        $testPacket->messages[] = $testMessage;
        $ret = $this->object->packetResponseDeserializedHandler($testPacket);
        $modifiedPacket = $ret[0];
        $modifiedObj = $modifiedPacket->messages[0]->data;
        $this->assertEquals("TestCustomClass1", $modifiedObj->$explicitTypeField);
        $this->assertEquals("bla1", $modifiedObj->data);
        $this->assertFalse(isset($modifiedObj->sub->$explicitTypeField));
        $this->assertEquals("bla2", $modifiedObj->sub->data);
        $this->assertEquals("TestCustomClass2", $modifiedObj->sub->sub->$explicitTypeField);
        $this->assertEquals("bla3", $modifiedObj->sub->sub->data);

        //test don't overwrite explicit type when already set
        $testObj2 = new TestCustomClass1();
        $testObj2->$explicitTypeField = "alreadySet";
        $testMessage = new Amfphp_Core_Amf_Message(null, null, $testObj2);
        $testPacket = new Amfphp_Core_Amf_Packet();
        $testPacket->messages[] = $testMessage;
        $ret = $this->object->packetResponseDeserializedHandler($testPacket);
        $modifiedPacket = $ret[0];
        $modifiedObj = $modifiedPacket->messages[0]->data;
        $this->assertEquals("alreadySet", $modifiedObj->$explicitTypeField);
    }

}

?>
